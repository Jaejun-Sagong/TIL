### 메모리의 동적 할당(dynamic allocation)

- 데이터 영역과 스택 영역에 할당되는 메모리의 크기는 컴파일 타임(compile time)에 미리 결정됩니다.
- 하지만 힙 영역의 크기는 프로그램이 실행되는 도중인 런 타임(run time)에 사용자가 직접 결정하게 됩니다.
- 이렇게 **런 타임에 메모리를 할당 받는 것**을 **메모리의 동적 할당**(dynamic allocation)이라고 합니다.

---

### malloc() 함수

- malloc() 함수는 프로그램이 실행 중일 때 사용자가 직접 힙 영역에 메모리를 할당할 수 있게 해줍니다.

malloc() 함수의 원형은 다음과 같습니다.

```cpp
#include <stdlib.h>

void *malloc(size_t size);
```

- malloc() 함수는 인수로 할당받고자 하는 메모리의 크기를 바이트 단위로 전달받습니다.이 함수는 전달받은 메모리 크기에 맞고, 아직 할당되지 않은 적당한 블록을 찾습니다.
이렇게 찾은 블록의 첫 번째 바이트를 가리키는 주소값을 반환합니다.
- 힙 영역에 할당할 수 있는 적당한 블록이 없을 때에는 널 포인터를 반환합니다.
- 주소값을 반환받기 때문에 힙 영역에 할당된 메모리 공간으로 접근하려면 포인터를 사용해야 합니다.
- malloc() 함수의 원형에서 볼 수 있는 size_t 타입은 부호 없는 정수라고 이해하면 됩니다.

---

### free() 함수

- free() 함수는 힙 영역에 할당 받은 메모리 공간을 다시 운영체제로 반환해 주는 함수입니다.
- 데이터 영역이나 스택 영역에 할당되는 메모리의 크기는 컴파일 타임에 결정되어, 프로그램이 실행되는 내내 고정됩니다.
- 하지만 메모리의 동적 할당으로 힙 영역에 생성되는 메모리의 크기는 런 타임 내내 변화됩니다.따라서 free() 함수를 사용하여 다 사용한 메모리를 해제해 주지 않으면, 메모리가 부족해지는 현상이 발생할 수 있습니다.
- 이처럼 사용이 끝난 메모리를 해제하지 않아서 메모리가 부족해지는 현상을 메모리 누수(memory leak)라고 합니다.

free() 함수의 원형은 다음과 같습니다.

```cpp
#include <stdlib.h>

void free(void *ptr);
```

free() 함수는 인수로 해제하고자 하는 메모리 공간을 가리키는 포인터를 전달받습니다.

인수의 타입이 void형 포인터로 선언되어 있으므로, 어떠한 타입의 포인터라도 인수로 전달될 수 있습니다.

다음 예제는 크기가 고정된 배열이 아닌 런 타임에 크기가 결정되는 배열을 생성하는 예제입니다.

### 예제

```cpp
ptr_arr = (int*) malloc(arr_len * sizeof(int)); *// 메모리의 동적* 할당 **

if (ptr_arr == NULL) *// 메모리의 동적* 할당*이 실패할 경우*

{

printf("메모리의 동적 할당에 실패했습니다.**\n**");

exit(1);

}

printf("동적으로 할당받은 메모리의 초깃값은 다음과 같습니다.**\n**");

for (i = 0; i < arr_len; i++)

{

printf("%d ****", ptr_arr[i]);

}

free(ptr_arr);       *// 동적으로 할당된 메모리의 반환*
```

### 실행 결과

동적으로 할당받은 메모리의 초기값은 다음과 같습니다.

0 0 0

---

### calloc() 함수

- calloc() 함수는 malloc() 함수와 마찬가지로 힙 영역에 메모리를 동적으로 할당해주는 함수입니다.
- 이 함수가 malloc() 함수와 다른 점은 할당하고자 하는 메모리의 크기를 두 개의 인수로 나누어 전달받는 점입니다.
또한, calloc() 함수는 메모리를 할당받은 후에 해당 메모리의 모든 비트값을 전부 0으로 초기화해 줍니다.
- calloc() 함수도 malloc() 함수와 마찬가지로 free() 함수를 통해 할당받은 메모리를 해제해 주어야 합니다.

calloc() 함수의 원형은 다음과 같습니다.

```cpp
#include <stdlib.h>

void *calloc(size_t nmemb, size_t size);
```

calloc() 함수의 첫 번째 인수는 메모리 블록의 개수를 나타내며, 두 번째 인수는 각 블록의 바이트 수를 나타냅니다.

따라서 calloc() 함수는 힙 영역에 size 크기의 메모리 블록을 nmemb개 할당받을 수 있도록 요청합니다.

앞선 예제에서 사용한 malloc() 함수와 다음 예제의 calloc() 함수는 똑같은 동작을 수행합니다.

### 예제

```cpp
1. ptr_arr = (int*) malloc(arr_len * sizeof(int));

2. ptr_arr = (int*) calloc(arr_len, sizeof(int));
```

---

### realloc() 함수

- realloc() 함수는 이미 할당된 메모리의 크기를 바꾸어 재할당할 때 사용하는 함수입니다.

realloc() 함수의 원형은 다음과 같습니다.

```cpp
#include <stdlib.h>

void *realloc(void *ptr, size_t size);
```

realloc() 함수의 첫 번째 인수는 크기를 바꾸고자 하는 메모리 공간을 가리키는 포인터를 전달받습니다.

두 번째 인수로는 해당 메모리 공간에 재할당할 크기를 전달합니다.

따라서 첫 번째 인수로 NULL이 전달되면, malloc() 함수와 정확히 같은 동작을 하게 됩니다.

다음 예제는 런 타임에 크기가 결정된 배열의 크기를 realloc() 함수를 사용해 다시 한 번 늘려주는 예제입니다.

```cpp
ptr_arr = (int*) malloc(arr_len * sizeof(int)); *// 메모리의 동적* 할당

if (ptr_arr == NULL) *// 메모리의 동적* 할당*이 실패할 경우*

{

printf("메모리의 동적 할당에 실패했습니다.**\n**");

exit(1);

}

printf("동적으로 할당받은 메모리의 초깃값은 다음과 같습니다.**\n**");

for (i = 0; i < arr_len; i++)

{

printf("%d ****", ptr_arr[i]);

}

total_len = arr_len + add_len;

ptr_arr = (int*) realloc(ptr_arr, (total_len * sizeof(int))); *// 메모리의 추가 할당*

if (ptr_arr == NULL) *// 메모리의 추가 할당에 실패할 경우*

{

printf("메모리의 추가 할당에 실패했습니다.**\n**");

exit(1);

}

printf("**\n**추가로 할당받은 메모리의 초깃값은 다음과 같습니다.**\n**");

for (i = 0; i < total_len; i++)

{

printf("%d ****", ptr_arr[i]);

}
free(ptr_arr); *// 동적으로 할당된 메모리의 반환*
```

### 실행 결과

동적으로 할당받은 메모리의 초기값은 다음과 같습니다.

0 0 0

추가로 할당받은 메모리의 초기값은 다음과 같습니다.

0 0 0 0 0

realloc() 함수는 만약 기존의 메모리 위치에 충분한 공간이 있다면 바로 이어서 추가 메모리 공간을 할당해 줍니다.

하지만 기존의 메모리 위치에 충분한 공간이 없으면 메모리의 다른 공간에 기존의 데이터를 복사한 후, 이어서 추가 메모리 공간을 할당하게 됩니다.
